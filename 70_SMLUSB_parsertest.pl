#!/bin/perl
use strict;
use warnings;


# New parser for 70_SMLUSB to be more flexible and intelligent
# Ready to be implemented into 70_SMLUSB
# ToDo:
# 
# 1. statusword parsing sucks. Find a good description to identify all informations (binary) out of the statusword.
#
# 2. same for unit and scaler!
#
# 3. Implement CRC16 check (for whole file and telegram/message)

my %obiscodes = (
 '77070100010800FF' => 'Zählerstand Bezug Total      ',
 '77070100020800FF' => 'Zählerstand Lieferung Total  ',
 '77070100010801FF' => 'Zählerstand Tarif 1 Bezug    ',
 '77070100020801FF' => 'Zählerstand Tarif 1 Lieferung',
 '77070100010802FF' => 'Zählerstand Tarif 2 Bezug    ',
 '77070100020802FF' => 'Zählerstand Tarif 2 Lieferung',
 '770701000F0700FF' => 'Momentanleistung',
 '77070100100700FF' => 'Momentanleistung',
 '77070100010700FF' => 'Momentanleistung Bezug - Voller');

my $smlfile;

#EHZ363WA
#$smlfile = "1B1B1B0101010176090000000003787BB362016200726301017601010900000000012828FE0B090148414700000370270101636A970076090000000003787BB4620162007263070177010B09014841470000037027070100620AFFFF7262016501D945D77777078181C78203FF01010101044841470177070100000009FF010101010B090148414700000370270177070100010800FF63028201621E52FF55058D9E020177070100010801FF0101621E52FF55020B969B0177070100010802FF0101621E52FF55038207660177070100100700FF0101621B52005300600177078181C78205FF01010101830215F0C14CCDD90D672023953F58F7E880879AC86A0CCBA59A715B783CB880969C2BC9A36E23096B10F37A777C528AA4F6010101637F370076090000000003787BB562016200726302017101636AC6001B1B1B1B1A008B02";

# ED300L
#$smlfile = "1B1B010101017607000A02792949620062007263010176010107000A01D90DC309080C2AEE2D4C4FB2010163C2CF007607000A0279294A6200620072630701770109080C2AEE2D4C4FB2070100620AFFFF7262016501D921BE7A77078181C78203FF0101010104454D480177070100000009FF0101010109080C2AEE2D4C4FB20177070100010800FF6401018201621E52FF5600018AFBB30177070100020800FF6401018201621E52FF560002B28E8C0177070100010801FF0101621E52FF5600018AFBB30177070100020801FF0101621E52FF560002B28E8C0177070100010802FF0101621E52FF5600000000000177070100020802FF0101621E52FF56000000000001770701000F0700FF0101621B52FF650000033B0177078181C78205FF017262016501D921BE01018302B129F735283A1BDE947854998A99985F91CF8C227D56885A7C54ED898B6BA534930154A11599F522F3DC0080223AC77A010101630080007607000A0279294D62006200726302017101630258000000001B1B1B1B1A038B68";

# ED300l Bezug
#my $smlfile = "1B1B1B1B010101017607000A02C72ED7620062007263010176010107000A01F30F9D09080C2AEE2D4C4FB20101639B75007607000A02C72ED86200620072630701770109080C2AEE2D4C4FB2070100620AFFFF7262016501F30CC67A77078181C78203FF0101010104454D480177070100000009FF0101010109080C2AEE2D4C4FB20177070100010800FF6401018201621E52FF56000199E5730177070100020800FF6401018201621E52FF560002E17CE40177070100010801FF0101621E52FF56000199E5730177070100020801FF0101621E52FF560002E17CE40177070100010802FF0101621E52FF5600000000000177070100020802FF0101621E52FF56000000000001770701000F0700FF0101621B52FF65000004840177078181C78205FF017262016501F30CC601018302B129F735283A1BDE947854998A99985F91CF8C227D56885A7C54ED898B6BA534930154A11599F522F3DC0080223AC77A0101016329A5007607000A02C72EDB6200620072630201710163E7D5000000001B1B1B1B1A03CEF3";

# Irgendwas
#$smlfile = "1B1B1B1B01010101760502BFBEC862006200726301017601010500EA94EE09080535342D4C92AD0101635ADE00760502BFBEC96200620072630701770109080535342D4C92AD070100620AFFFF726201650280C70E7B77078181C78203FF010101010449534B0177070100000009FF0101010109080535342D4C92AD0177070100010800FF650000018201621E52FF5900000000019EBA410177070100010801FF0101621E52FF5900000000019EBA410177070100010802FF0101621E52FF59000000000000000001770701000F0700FF0101621B5200650000008C0177070100150700FF0101621B520065000000010177070100290700FF0101621B5200650000008901770701003D0700FF0101621B520065000000010177070100600505FF0101010165000001820177078181C78205FF0101010183022A101995CE5A871E0CC67020E497B56B3CA68D4C7BA18016DE8C6EE09649AB4CDF8189F6B1AD2E29F0A4C6D2D46CCC5B010101632E3700760502BFBECA6200620072630201710163292C001B1B1B1B1A001942";

# Irgendwas anderes
#$smlfile = "1B1B1B1B010101017605000157BA6200620072630101760101050000728E0B0649534B0104CEE5A9CD010163029B007605000157BB620062007263070177010B0649534B0104CEE5A9CD070100620AFFFF72620165000073DB7A77078181C78203FF010101010449534B0177070100000009FF010101010B0649534B0104CEE5A9CD0177070100010800FF650001010001621E52FF5900000000000176FE0177070100010801FF0101621E52FF590000000000016E4F0177070100010802FF0101621E52FF5900000000000008AF0177070100020800FF650001010001621E52FF5900000000000042940177070100020801FF0101621E52FF5900000000000042940177070100020802FF0101621E52FF5900000000000000000177070100100700FF0101621B520055000000000177078181C78205FF010101018302ECFD72FEFFBD79ADF67E06E95026DFB6C6E4AB0FE76F2F108887F7294CC96C9C093F016127A6A2E6AA665F79442F2CDF01010163AE56007605000157BC6200620072630201710163BD3E001B1B1B1B1A00D258";

#Q3 von voller
#$smlfile ="1B1B1B1B01010101760551EEEFCF62006200726500000101760101074553595133420B0645535901071BB1430F010163A9AC00760551EEEFD06200620072650000070177010B0645535901071BB1430F01726201650027E3237977078181C78203FF01010101044553590177070100010800FF0101621E52FC690000000063A6A6480177070100020800FF0101621E52FC6900000000AF8A98FE0177070100010801FF0101621E520165000040C60177070100010802FF0101621E520165000000880177070100020801FF0101621E520165000072870177070100020802FF0101621E520165000000830177070100010700FF0101621B52FE55FFFD57F00177070100600505FF010101016301A00101016360D700760551EEEFD1620062007265000002017101630A8200001B1B1B1B1A01A3FF";

#Hager EHZ363Z5 von zYloriC
#$smlfile = "1B1B1B1B01010101760900000000055BC4136201620072630101760101090000000001C9415D0B06484147010754DED5CF01016303A100760900000000055BC414620162007263070177010B06484147010754DED5CF070100620AFFFF7262016502981D977A77078181C78203FF01010101044841470177070100000009FF010101010B06484147010754DED5CF0177070100010800FF628201621E52FF5502AB1B850177070100010801FF0101621E52FF5502AAF4750177070100010802FF0101621E52FF5327100177070100020800FF628201621E52FF55031FEB190177070100020801FF0101621E52FF55031FC4090177070100020802FF0101621E52FF5327100177070100100700FF0101621B52005301EE0177078181C78205FF0101010183029B147C682819FB0365A1AC68A7238153B1332CB24645E0CA769E8CA72CAC1603E84166642811060867CC46A9F87AF959010101634AB700760900000000055BC41762016200726302017101633FB0001B1B1B1B1A0050791B1B1B1B01010101760900000000055BC4196201620072630101760101090000000001C9415F0B06484147010754DED5CF010163A76100760900000000055BC41A620162007263070177010B06484147010754DED5CF070100620AFFFF7262016502981D997A77078181C78203FF01010101044841470177070100000009FF010101010B06484147010754DED5CF0177070100010800FF628201621E52FF5502AB1B870177070100010801FF0101621E52FF5502AAF4770177070100010802FF0101621E52FF5327100177070100020800FF628201621E52FF55031FEB190177070100020801FF0101621E52FF55031FC4090177070100020802FF0101621E52FF5327100177070100100700FF0101621B52005301ED0177078181C78205FF0101010183029B147C682819FB0365A1AC68A7238153B1332CB24645E0CA769E8CA72CAC1603E84166642811060867CC46A9F87AF95901010163922400760900000000055BC41B6201620072630201710163C052001B1B1B1B1A00F15F";

#ED300S von Blackstone
$smlfile ="1B1B1B0101010176070008000F8493620062007263010176010107000800042C310B0901454D4800004FC951010163BDEE0076070008000F8494620062007263070177010B0901454D4800004FC951070100620AFFFF726201650004F85E7677078181C78203FF0101010104454D480177070100000000FF010101010E303130373130353232383838310177070100000001FF010101010F31454D48303030353232383838310177070100000009FF010101010B0901454D4800004FC9510177070100010800FF6400008001621E52FF560000062AED0177070100100700FF01726201650004F85E621B52FF55000002BD01010163697D0076070008000F84976200620072630201710163219200001B1B1B01010101760700080033ECF7620062007263010176010107000800104EFD0B0901454D4800004FC9510101635BC900760700080033ECF8620062007263070177010B0901454D4800004FC951070100620AFFFF72620165001022047677078181C78203FF0101010104454D480177070100000000FF010101010E303130373130353232383838310177070100000001FF010101010F31454D48303030353232383838310177070100000009FF010101010B0901454D4800004FC9510177070100010800FF6400008201621E52FF56000015F90F0177070100100700FF017262016500102204621B52FF55000015FE0101016342BF00760700080033ECFB6200620072630201710163C1FD00001B1B1B1B1A01FCCC";

#1B1B1B1B01010101760900000000055BC41F6201620072630101760101090000000001C941610B06484147010754DED5CF0101631E1F00760900000000055BC420620162007263070177010B06484147010754DED5CF070100620AFFFF7262016502981D9B7A77078181C78203FF01010101044841470177070100000009FF010101010B06484147010754DED5CF0177070100010800FF628201621E52FF5502AB1B8A0177070100010801FF0101621E52FF5502AAF47A0177070100010802FF0101621E52FF5327100177070100020800FF628201621E52FF55031FEB190177070100020801FF0101621E52FF55031F";


# Inputvalue is $smlfile. This part checks if the SML header and footer are available and complete

if ($smlfile =~ m/1B1B1B1B1A[0-9A-F]{6}$/) {
  if ($smlfile =~ m/^1B1B1B1B01010101/) {
    print "Header - OK\n"; } 
  else {
    if ($smlfile =~ m/^(1B){0,4}01010101/) {
      $smlfile =~ s/^(1B){0,4}01010101/1B1B1B1B01010101/g;
      print "Header - Repaired\n";} 
    else {
      print "Header - No header found!\n";}
  }} 
else {
  print "Footer - No footer found\n";
}
 
my $telegramm;
my $scaler;
my $typelength;
my $unit;
my $direction;

my $length_all = 0;
my $length_value = 0;


# Try to find a SML telegramm in the SML file

  while ($smlfile =~ m/7707[0-9A-F]{10}FF[0-9A-F]{16,9999}/) {
    $telegramm = $&;

    # Try to find the OBIS code in the hash of known and supported OBIS codes
    # OBIS Code with the start (7707) is always 8 bit long (16 nible)
 
    if (defined $obiscodes{substr($telegramm,0,16)}) {
    
      # OBIS code found start parsing
    
      $length_all   = 16;    
      $length_value = 0;

      print "USB: SML Telegram found: " . substr($telegramm,0,16) . "\n";

      # Detect length of status word (very static at the moment)
      # You can find more information if you google for type length field
      # 01 = Statusword not set
      # 62 is (6 = no more tl fields and type = unsigned?, 2 = 2 bytes or 4 hex chars)
       
      $length_all+=hexstr_to_signed32int(substr($telegramm,17,1))*2+2;
        
      # Detect the direction of engergy from the status word
      my $direction = "Nothing"; 
      $direction = "Bezug"       if (substr($telegramm,$length_all-4,2) eq "82");
      $direction = "Einspeisung" if (substr($telegramm,$length_all-4,2) eq "A2");
	
      print "valTime = " . substr($telegramm,$length_all-2,2) . "\n";

      $length_all+=14		 if (substr($telegramm,$length_all-2,2) eq "72");

      # Detect the unit. Also very static and could be improved

		  if (substr($telegramm,$length_all,4) eq "621E") {
			$unit = "W/h"; }
		  else {
			$unit = "W"; }

      $length_all+=4;

      # Detect the scaler. Also very static and could be improved

      $scaler=10 if (substr($telegramm,$length_all,4) eq "52FF"); 
      $scaler=1  if (substr($telegramm,$length_all,4) eq "5200");
      $scaler=1  if (substr($telegramm,$length_all,4) eq "5201");
      $length_all+=4;

      # Detect the value length.

      $length_value=hexstr_to_signed32int(substr($telegramm,$length_all+1,1))*2;
      $length_all+=2;   
   
      # If value is bigger than 9999 W/h change to kW/h 

		if (sprintf("%.2f",hexstr_to_signed32int(substr($telegramm,$length_all,$length_value-2))/$scaler) > 9999) { 
			$scaler = 10000; 
			$unit = "kW/h"; 
			print "Bigger\n"; }

      # Output of results only if a meaningful value is found. Otherwise nothing happens.

		if (sprintf("%.2f",hexstr_to_signed32int(substr($telegramm,$length_all,$length_value-2))/$scaler) > 0) {
			#Log3 $hash, 5, "SMLUSB: Reading BulkUpdate. Value > 0";
			
			if ((substr($telegramm,0,16) eq "770701000F0700FF") || (substr($telegramm,0,16) eq "77070100100700FF")) {
				#Log3 $hash, 5, "SMLUSB: Setting state";
				print "$unit: " . sprintf("%.2f",hexstr_to_signed32int(substr($telegramm,$length_all,$length_value-2))/$scaler) . " - $direction\n";
					if ($direction eq "Einspeisung") {
						print $obiscodes{substr($telegramm,0,16)}; 
						print sprintf("%.2f",hexstr_to_signed32int(substr($telegramm,$length_all,$length_value-2))/$scaler*-1)."\n";
					}
					else {
						print $obiscodes{substr($telegramm,0,16)}; 
						print sprintf("%.2f",hexstr_to_signed32int(substr($telegramm,$length_all,$length_value-2))/$scaler)."\n";
					}
			}
			else {
				print $obiscodes{substr($telegramm,0,16)}; 
				print sprintf("%.2f",hexstr_to_signed32int(substr($telegramm,$length_all,$length_value-2))/$scaler)."\n";
			}
		}
		 print "RAW : " . substr($telegramm,$length_all,$length_value-2) . "\n";
	}	
    else {
      # If no known OBIS code can be found the telegramm will be ignored (or logged)
      # print "No Obis Code found!: " . substr($telegramm,0,16) ."\n"; 
      # The telegramm  header needs at least to be removed from the smlfile to detect the next one.
      $length_all=16; 
    }
 
    # Remove found telegram from remaining sml file.
	#print $smlfile;
	#print "Diagnose: ";
	#print " Length all: $length_all";
	#print " Length value: $length_value";
	#print " Length smlfile: ";
	#print length($smlfile)."\n";
	
    $smlfile = substr($smlfile,index($smlfile,$&)+$length_all+$length_value,length($smlfile));
  }

  # No good crc16 function found or developed yet. This is a todo
  #my $crc = substr($smlfile,length($smlfile)-4,4);
  #print "CRC: $crc - \n";

  #Log3 $hash, 5, "SMLUSB: Parsing ended";

  #readingsEndUpdate($hash, 1); 

  #return undef;


#####################################
sub hexstr_to_signed32int {
    my ($hexstr) = @_;
    return 0  
      if $hexstr !~ /^[0-9A-Fa-f]{1,35}$/;
    my $num = hex($hexstr);
    return $num >> 31 ? $num - 2 ** 32 : $num;
}
